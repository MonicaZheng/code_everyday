9.10:
1. two sum: 不熟练
2. 34. Find First and Last Position of Element in Sorted Array：binary search
3. 50. Pow(x, n): binsry searvh log(n)
4. 69. Sqrt(x)


9.13
1. 144. Binary Tree Preorder Traversal. 重写
2. 200. Number of Islands
3. 102. Binary Tree Level Order Traversal
4. 100. Same Tree 重写 ： > Time Complexity O(N)
> Space Complexity O(h)
5. 101. Symmetric Tree: 时间复杂度 : O(N)
空间复杂度 : O(N) or O(Height)
6. 127. Word Ladder
7. 387. First Unique Character in a String
8. 1. Two Sum
9. 125. Valid Palindrome 双指针！重写
10. 104. Maximum Depth of Binary Tree: O(n)
11. 53. Maximum Subarray!!重写： res = -sys.maxsize - 1
12. 173. Binary Search Tree Iterator >>>> inorder traverse! 重写
13. 94. Binary Tree Inorder Traversal
14. 20. Valid Parentheses!!! stack, 重写，特殊情况判断

9.14
1. 144. Binary Tree Preorder Traversal: stack
2. 125. Valid Palindrome

9.15
1. 53. Maximum Subarray
2. 205. Isomorphic Strings 重写
3. 235. Lowest Common Ancestor of a Binary Search Tree !!重要
4. 236. Lowest Common Ancestor of a Binary Tree!重要
5. 33. Search in Rotated Sorted Array 重写

9.16
1. 244. Shortest Word Distance II
2. 170. Two Sum III - Data structure design
3. 341. Flatten Nested List Iterator!!! stack 重写
4. 101. Symmetric Tree

9.17
1. 33. Search in Rotated Sorted Array
2. 243. Shortest Word Distance 双指针！重写
3. 244. Shortest Word Distance II !重写
4. 339. Nested List Weight Sum, 重写
5. 364. Nested List Weight Sum II
6. 235. Lowest Common Ancestor of a Binary Search Tree

9.18
1. 46. Permutations, 重要
The complexity is proportional to the size of the output (number of permutations). Just imagine that for the first position you have n possible candidates, then for the second position you have n-1 possible candidates (as the one is already taken in the first position), for the 3rd position you have n-2 candidates, etc. Therefore the complexity is O(n!). 

9.19
1. 47. Permutations II
2. 46. Permutations
3. 339. Nested List Weight Sum 重要！！！！stack 写法！！！

9.20 
1. 364. Nested List Weight Sum II
2. 53. Maximum Subarray
3. 605. Can Place Flowers ! 重要！
4. 341. Flatten Nested List Iterator: stack!!
5. 380. Insert Delete GetRandom O(1)!! list+ hashmap 重要
6. 150. Evaluate Reverse Polish Notation! 重要
7. 671. Second Minimum Node In a Binary Tree， 重写

9.21
1. 205. Isomorphic Strings
2. 236. Lowest Common Ancestor of a Binary Tree
3. 449. Serialize and Deserialize BST， 重写： if node:
                queue.append(node.left)
                queue.append(node.right)
4. 297. Serialize and Deserialize Binary Tree
5. 56. Merge Intervals 重要
6. 744. Find Smallest Letter Greater Than Target
7. 57. Insert Interval ：重新写 o(n) 的方法
8. 349. Intersection of Two Arrays
9. 39. Combination Sum, 重写！

9.22
1. 39. Combination Sum!!! 记得 sort
2. 40. Combination Sum II
3. 254. Factor Combinations!!!重写
4. 605. Can Place Flowers
5. 366. Find Leaves of Binary Tree, dictionary, 重写
6. 156. Binary Tree Upside Down, stack 重写！！！

9.23
1. 739. Daily Temperatures, satck, 重写
2. 339. Nested List Weight Sum

9.27
1. 739. Daily Temperatures, 重写！！！
2. 39. Combination Sum
3. 144. Binary Tree Preorder Traversal
4.94. Binary Tree Inorder Traversal
5. 173. Binary Search Tree Iterator
6. 156. Binary Tree Upside Down
7. 254. Factor Combinations1 重写
